/**
 * @kchavali_assignment1
 * @author  Krishnakant Chavali <kchavali@buffalo.edu>
 * @version 1.0
 *
 * @section LICENSE
 *
 * References: http://www.logix.cz/michal/devel/various/getaddrinfo.c.xp, http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html, http://www.youtube.com/watch?v=V6CohFrRNTo&list=PLA11IfH218umj27YmnMWn752Kj6PS1UOy
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details at
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @section DESCRIPTION
 *
 * This contains the main function. Add further description here....
 */
#include<stdio.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include <stdlib.h>

//#include "../include/global.h"

/**
 * main function
 *
 * @param  argc Number of arguments
 * @param  argv The argument list
 * @return 0 EXIT_SUCCESS
 */
int main(int argc, char *argv[])
{
	printf("%s",argv[1]);
	if(strcmp(argv[1], "s") == 0)
	{
		int sockfd, newsockfd, portno, clilen;
		char buffer[256];
		struct sockaddr_in serv_addr, cli_addr;
		int n;
		
		if (argc < 3)
		{
			fprintf(stderr,"ERROR, no port provided\n");
			exit(1);
		}
		
		sockfd = socket(AF_INET, SOCK_STREAM, 0);
		
		if (sockfd < 0)
		{	
			error("ERROR opening socket");
		}
	
		bzero((char *) &serv_addr, sizeof(serv_addr));

		portno = atoi(argv[2]);
	
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_addr.s_addr = INADDR_ANY;
		serv_addr.sin_port = htons(portno);
		
		
		if (bind(sockfd, (struct sockaddr *) &serv_addr,sizeof(serv_addr)) < 0)
		{
			error("ERROR on binding");
		}
		
		listen(sockfd,5);
		clilen = sizeof(cli_addr);
	
		newsockfd = accept(sockfd,(struct sockaddr *) &cli_addr, &clilen);
	
		if (newsockfd < 0)
		{
			error("ERROR on accept");
		}

		bzero(buffer,256);

		n = read(newsockfd,buffer,255);

		if (n < 0)
		{
			error("ERROR reading from socket");
		}
		
		printf("Here is the message: %s\n",buffer);
	
		n = write(newsockfd,"I got your message",18);

		if (n < 0)
		{
			error("ERROR writing to socket");
		}
		
	
		//int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);
		//if(<0)
		//{
		//	printf("Error");
		//} 
		
		/*	void *get_ip_str(const struct sockaddr *sa, char *s, size_t maxlen)
		{
 			switch(sa->sa_family) 
			{
 		       case AF_INET:
 		           inet_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr),
                    s, maxlen);
     		       break;

   		     case AF_INET6:
   		         inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr),
                    s, maxlen);
  		          break;
		
  		      default:
  		          strncpy(s, "Unknown AF", maxlen);
            
			}

   		 printf("The IP Address is: %s\n",s);
		}
		*/



		/*
		struct sockaddr_in sa; // IPv4
		inet_pton(AF_INET, "192.0.2.1", &(sa.sin_addr)); // IPv4


		char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
		struct sockaddr_in sa;      // pretend this is loaded with something

		inet_ntop(AF_INET, &(sa.sin_addr), ip4, INET_ADDRSTRLEN);

		printf("The IPv4 address is: %s\n", ip4);
		*/

	
	}
	else if(strcmp(argv[1], "c") == 0)
	{
	}
	else{
	printf("Please enter s - Server, c - Client\n");
	}

	return 0;
}
